<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Mitsy’s Revenge</title>
<style>
  :root { --ui: rgba(0,0,0,.65); --ui2: rgba(0,0,0,.35); }
  html,body { margin:0; height:100%; background:#111; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  #wrap { position:fixed; inset:0; display:grid; place-items:center; }
  canvas { width:100vw; height:100vh; display:block; background:#000; touch-action:none; }
  /* Splash */
  #splash {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:#000; z-index:10;
  }
  #splash .panel {
    position:relative; width:min(1100px,95vw); aspect-ratio:16/9; display:grid; place-items:center;
    background:#000; overflow:hidden; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.6);
  }
  #splash img.bg {
    position:absolute; inset:0; width:100%; height:100%; object-fit:cover; filter:brightness(.6) contrast(1.05);
  }
  #splash .content {
    position:relative; padding:24px; text-align:center; display:grid; gap:10px;
    grid-auto-rows:max-content;
  }
  #splash h1 { margin:0; font-size:clamp(28px,5vw,56px); letter-spacing:.5px; }
  #splash p  { margin:0; font-size:clamp(14px,2.2vw,20px); opacity:.95; }
  #startBtn {
    justify-self:center; margin-top:12px; padding:14px 22px; font-weight:700; font-size:clamp(14px,2.4vw,18px);
    color:#fff; background:#0ea5e9; border:0; border-radius:999px; cursor:pointer;
    box-shadow:0 6px 16px rgba(14,165,233,.45);
  }
  #startBtn:active{ transform:translateY(1px); }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
         background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.15); border-bottom-width:3px; border-radius:6px; padding:2px 6px; }
  /* HUD */
  #hud {
    position:fixed; inset:0; pointer-events:none; z-index:5; font-weight:700;
    text-shadow:0 2px 4px rgba(0,0,0,.6);
  }
  #hud .tl, #hud .tr, #hud .tc {
    position:absolute; top:10px; padding:6px 10px; background:var(--ui2); border-radius:10px;
    backdrop-filter: blur(6px);
  }
  #hud .tl { left:10px; }
  #hud .tr { right:10px; }
  #hud .tc { left:50%; transform:translateX(-50%); display:none; }
  /* Smoke button (touch) */
  #smokeBtn {
    position:fixed; right:14px; bottom:14px; z-index:6; display:none;
    padding:14px 18px; border-radius:999px; border:0; font-weight:800; letter-spacing:.5px;
    background:#22c55e; color:#08170c; box-shadow:0 8px 24px rgba(34,197,94,.4);
  }
  #smokeBtn:active{ transform:translateY(1px); }
  /* End overlay */
  #end {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20;
    background:rgba(0,0,0,.75); text-align:center; padding:20px;
  }
  #end .card { background:rgba(20,20,20,.8); padding:28px 22px; border-radius:16px; max-width:min(680px,92vw); }
  #end h2 { margin:0 0 8px; font-size:clamp(22px,5vw,36px); }
  #end p { margin:0; opacity:.9; }
  /* Video layer (intro) */
  #intro {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:15;
    background:#000;
  }
  #intro video { width:min(1100px,96vw); max-height:96vh; background:#000; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="720"></canvas>
</div>

<!-- HUD -->
<div id="hud">
  <div class="tl" id="invLabel">Nugs: 0/2</div>
  <div class="tr" id="smokedLabel">Smoked: 0</div>
  <div class="tc" id="prompt">Press <span class="kbd">S</span> to smoke</div>
</div>
<button id="smokeBtn" aria-label="Smoke">SMOKE</button>

<!-- Splash -->
<div id="splash" role="dialog" aria-modal="true">
  <div class="panel">
    <img class="bg" src="splash image.png" alt="" />
    <div class="content">
      <h1>Mitsy’s Revenge</h1>
      <p><em>Collect nugs, blaze when you’ve got two, smoke it up.</em></p>
      <p>
        Controls: <span class="kbd">A</span>/<span class="kbd">D</span> move,
        <span class="kbd">Space</span> jump, <span class="kbd">S</span> smoke.
      </p>
      <button id="startBtn">Start &amp; Watch Intro</button>
    </div>
  </div>
</div>

<!-- Unskippable intro video layer -->
<div id="intro">
  <video id="introVid" src="intro video.mp4" preload="auto" playsinline></video>
</div>

<!-- Audio elements (created as HTMLAudio so browser autoplay policies are happy after click) -->
<audio id="bgm" src="Welcome to...The Streets of Aberdeen .mp3" preload="auto" loop></audio>

<script>
(() => {
  // --- Canvas & world ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Fixed internal resolution; canvas CSS scales to viewport for crispness.
  const VIEW_W = 1280, VIEW_H = 720;
  canvas.width = VIEW_W; canvas.height = VIEW_H;

  const GROUND_Y = VIEW_H - 120;  // flat ground
  const LEVEL_W = 6000;           // long enough for camera pan & many pickups

  // --- Assets ---
  const IMAGES = {
    bg: "bg.png",
    cat_idle: "sit.png",
    cat_walk: "walk.png",
    cat_smoke: "smoke.png",
    weed: "weed.png",
    joint: "joint.png",
    bong: "bong.png"
  };

  const SFX_FILES = [
    "Recording (16).m4a",
    "Recording (17).m4a",
    "Recording (18).m4a",
    "Recording (19).m4a",
    "Recording (20).m4a",
    "Recording (21).m4a",
    "Recording (22).m4a",
    "Recording (23).m4a",
    "Recording (24).m4a",
    "Recording new (18).m4a",
    "Recording new (19).m4a"
  ];

  const BGM = document.getElementById('bgm'); // background music element

  const loadImage = (src) => new Promise((res, rej) => { const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; });
  const loadAudio = (src) => new Promise((res) => { const a = new Audio(src); a.preload="auto"; a.oncanplay=res; a.onerror=res; a.load(); res(a); });

  const assets = { images:{}, sfx:[] };

  // --- Game State ---
  const state = {
    started:false,
    inVideo:false,
    playing:false,
    ended:false,
    time:0,
    freezeUntil:0,
    camX:0,
    cat:{
      x: 200, y: GROUND_Y - 120, w:120, h:120,
      vx:0, vy:0,
      onGround:true,
      facing:1, // 1 right, -1 left
      sprite:"idle",
      smokeUntil:0
    },
    pickups:[],
    inv:0,
    smoked:0,
    nextCatchIndex:0,
    nextSfxIndex:0,
    catchPhrases: [],
    sfxOrder: []
  };

  // Catchphrases list (exact, in randomized no-repeat order per game)
  const CATCHES = [
    "Jackpot! That’s some primo meowijuana.",
    "One man’s weed… is every cat’s weed.",
    "This batch smells like trouble… and I’m into it.",
    "Purr-fection in plant form.",
    "Hydroponics? More like hydropurr-nics.",
    "Snoop Dogg? More like Snoop Cat.",
    "Mine. Mine. Also mine.",
    "Nobody’s taking this from me. Not even the vacuum.",
    "I’ll bury this later… maybe in the litter box.",
    "I like my buds big and sticky.",
    "I’ve been a naughty pussy.",
    "This pussy’s out of control.",
    "This pussy’s lit.",
    "I hope it doesn’t rain… or we’ll have a wet pussy on our hands.",
    "What’s a cat’s favorite film genre? ‘Cat-nip-and-chill’ movies."
  ];

  // --- UI Elements ---
  const invLabel = document.getElementById('invLabel');
  const smokedLabel = document.getElementById('smokedLabel');
  const prompt = document.getElementById('prompt');
  const smokeBtn = document.getElementById('smokeBtn');

  // --- Input ---
  const keys = { a:false, d:false, s:false, space:false };
  addEventListener('keydown', (e) => {
    if (!state.playing || state.ended) return;
    if (e.code === 'KeyA') keys.a = true;
    if (e.code === 'KeyD') keys.d = true;
    if (e.code === 'Space') { e.preventDefault(); keys.space = true; }
    if (e.code === 'KeyS') { e.preventDefault(); trySmoke(); }
  });
  addEventListener('keyup', (e) => {
    if (e.code === 'KeyA') keys.a = false;
    if (e.code === 'KeyD') keys.d = false;
    if (e.code === 'Space') keys.space = false;
  });

  // Touch-only on-screen SMOKE button (spec requires this one; movement remains keyboard)
  smokeBtn.addEventListener('click', trySmoke);

  // --- Helpers ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const now = () => performance.now();

  function shuffle(arr) {
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--) { const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; }
    return a;
  }

  // Build pickups: at least 36 across a flat level
  function buildPickups() {
    const sprites = ['weed','joint','bong'];
    const total = 40; // >=36 so player can do all 15 smokes
    const margin = 200;
    const stepMin = 90, stepMax = 220;
    let x = 400;
    for (let i=0;i<total;i++) {
      const kind = sprites[(Math.random()*sprites.length)|0];
      const y = GROUND_Y - 40 - Math.round(Math.random()*10); // near ground
      state.pickups.push({ x, y, r:28, kind, taken:false });
      x += stepMin + Math.random()*(stepMax-stepMin);
      if (x > LEVEL_W - margin) x = LEVEL_W - margin - (Math.random()*300);
    }
  }

  // --- Loading ---
  async function loadAll() {
    // Images
    for (const [k,src] of Object.entries(IMAGES)) {
      assets.images[k] = await loadImage(src);
    }
    // SFX
    for (const f of SFX_FILES) {
      const a = await loadAudio(f);
      a.volume = 1.0;
      assets.sfx.push(a);
    }
  }

  // --- Rendering helpers ---
  function drawImage(img, x,y,w,h, flip=false) {
    ctx.save();
    if (flip) { ctx.translate(x+w, y); ctx.scale(-1,1); ctx.drawImage(img, 0,0,w,h); }
    else { ctx.drawImage(img, x,y,w,h); }
    ctx.restore();
  }

  function drawSpeechBubble(text, screenX, screenY) {
    // Text spec: 28px, white with black outline, ~180px above cat top
    ctx.save();
    ctx.font = '28px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Wrap text to max width
    const maxW = 640;
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for (const w of words) {
      const test = line ? line + ' ' + w : w;
      if (ctx.measureText(test).width < maxW) line = test;
      else { lines.push(line); line = w; }
    }
    if (line) lines.push(line);

    // Bubble box
    const padX = 18, padY = 12, lineH = 34;
    const boxW = Math.min(maxW, Math.max(220, Math.max(...lines.map(l => ctx.measureText(l).width))+padX*2));
    const boxH = lines.length*lineH + padY*2;
    const bx = screenX - boxW/2;
    const by = screenY - boxH;

    // Bubble shape
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    roundRect(ctx, bx, by, boxW, boxH, 14);
    ctx.fill();
    // Tail
    ctx.beginPath();
    ctx.moveTo(screenX-14, by+boxH);
    ctx.lineTo(screenX+14, by+boxH);
    ctx.lineTo(screenX, by+boxH+18);
    ctx.closePath();
    ctx.fill();

    // Text with outline
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'black';
    ctx.fillStyle = 'white';
    lines.forEach((l,i)=>{
      const ty = by + padY + i*lineH + lineH/2;
      ctx.strokeText(l, screenX, ty);
      ctx.fillText(l, screenX, ty);
    });

    ctx.restore();
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // --- Game Flow: splash -> wait 6s -> intro video -> game ---
  const splashEl = document.getElementById('splash');
  const introEl = document.getElementById('intro');
  const introVid = document.getElementById('introVid');
  const startBtn = document.getElementById('startBtn');

  startBtn.addEventListener('click', async () => {
    if (state.started) return;
    state.started = true;

    // begin bgm immediately (looping)
    try { BGM.volume = 1.0; await BGM.play(); } catch(e){ /* ignored, user gesture should allow */ }

    // After 6000ms, play video (unskippable)
    splashEl.style.display = 'none';
    state.inVideo = true;
    introEl.style.display = 'flex';
    setTimeout(async () => {
      try {
        await introVid.play();
      } catch(e) {
        // Some mobile devices require user tap on video; if it fails, show simple fallback poster for duration equal to video length guess.
        // But spec says video cannot be skipped; we still gate gameplay until 'ended'.
        introVid.muted = true;
        await introVid.play().catch(()=>{});
      }
    }, 6000);
  });

  introVid.addEventListener('ended', () => {
    introEl.style.display = 'none';
    state.inVideo = false;
    beginGameplay();
  });

  async function beginGameplay(){
    await loadAll();
    state.playing = true;
    state.time = now();
    state.catchPhrases = shuffle(CATCHES);
    state.sfxOrder = shuffle([...assets.sfx.keys()]);
    buildPickups();
    requestAnimationFrame(tick);
  }

  // --- Smoking mechanics ---
  let speaking = { active:false, until:0, text:"" };

  function trySmoke() {
    if (!state.playing || state.ended) return;
    if (state.inv < 2) return;
    if (state.time < state.freezeUntil) return; // frozen during bubble

    // Spend 2 pickups
    state.inv -= 2;
    state.smoked += 1;

    // Choose next SFX and catchphrase (no repeats until exhausted)
    const sfxIndex = nextSfxIndex();
    const phrase = nextCatch();

    // Play SFX and duck music
    playSfxWithDuck(sfxIndex, 0.25, 1500);

    // Show speech bubble for 2200ms; freeze gameplay for first 1500ms
    speaking.active = true;
    speaking.text = phrase;
    speaking.until = now() + 2200;
    state.freezeUntil = now() + 1500;

    // Smoking pose for duration
    state.cat.smokeUntil = now() + 1500;

    // If last catchphrase was used, end game when bubble finishes
    if (allCatchphrasesUsed()) {
      setTimeout(endGame, 2200);
    }
  }

  function nextSfxIndex() {
    if (state.nextSfxIndex >= state.sfxOrder.length) {
      state.sfxOrder = shuffle([...assets.sfx.keys()]);
      state.nextSfxIndex = 0;
    }
    return state.sfxOrder[state.nextSfxIndex++];
  }

  function nextCatch() {
    const idx = state.nextCatchIndex++;
    if (idx >= state.catchPhrases.length) {
      // reshuffle if somehow called again (should only happen after end)
      state.catchPhrases = shuffle(CATCHES);
      state.nextCatchIndex = 1;
      return state.catchPhrases[0];
    }
    return state.catchPhrases[idx];
  }

  function allCatchphrasesUsed(){ return state.nextCatchIndex >= CATCHES.length; }

  function playSfxWithDuck(sfxIdx, duckTo=0.25, duckMs=1500) {
    const sfx = assets.sfx[sfxIdx];
    if (!sfx) return;

    // Reset sfx and play
    try { sfx.currentTime = 0; } catch(e){}
    sfx.volume = 1.0;
    sfx.play().catch(()=>{});

    // Duck BGM immediately
    const orig = BGM.volume;
    BGM.volume = duckTo;

    // Fade back up after duckMs
    const start = now() + duckMs;
    const fadeDur = 800;
    const step = () => {
      const t = now() - start;
      if (t < 0) { requestAnimationFrame(step); return; }
      const k = clamp(t / fadeDur, 0, 1);
      BGM.volume = lerp(duckTo, 1.0, k);
      if (k < 1) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  function endGame(){
    state.ended = true;
    // Freeze everything and show end overlay with exact text
    document.getElementById('end').style.display = 'flex';
    // Stop inputs from further actions (we leave music playing softly)
  }

  // --- Main loop ---
  function tick(t) {
    const dt = Math.min(33, t - state.time); // clamp delta
    state.time = t;

    logic(dt);
    render();

    if (!state.ended) requestAnimationFrame(tick);
  }

  function logic(dt) {
    const cat = state.cat;

    const frozen = state.time < state.freezeUntil;
    const speed = 0.48 * dt; // px per ms
    const jumpVy = -0.9 * dt; // scaled jump impulse relative to frame

    if (!frozen) {
      cat.vx = 0;
      if (keys.a) { cat.vx = -speed; cat.facing = -1; }
      if (keys.d) { cat.vx = +speed; cat.facing = +1; }
      if (keys.space && cat.onGround) {
        cat.vy = jumpVy; cat.onGround = false;
      }
    } else {
      cat.vx = 0; // no movement during freeze
    }

    // Gravity
    cat.vy += 0.0025 * dt; // gravity
    // Integrate
    cat.x += cat.vx;
    cat.y += cat.vy;

    // Ground collision
    const feet = GROUND_Y - cat.h;
    if (cat.y >= feet) {
      cat.y = feet;
      cat.vy = 0;
      cat.onGround = true;
    }

    // Keep within level
    cat.x = clamp(cat.x, 0, LEVEL_W - cat.w);

    // Sprite state
    if (state.time < cat.smokeUntil) cat.sprite = 'smoke';
    else if (Math.abs(cat.vx) > 0.01) cat.sprite = 'walk';
    else cat.sprite = 'idle';

    // Camera follows
    const targetCam = clamp(cat.x + cat.w/2 - VIEW_W/2, 0, LEVEL_W - VIEW_W);
    state.camX = lerp(state.camX, targetCam, 0.12);

    // Pickups collection
    for (const p of state.pickups) {
      if (p.taken) continue;
      const cx = cat.x + cat.w/2, cy = cat.y + cat.h/2;
      const dx = (p.x + 24) - cx;
      const dy = (p.y + 24) - cy;
      const d2 = dx*dx + dy*dy;
      if (d2 < (60*60)) { // simple radius check
        p.taken = true;
        state.inv += 1;
      }
    }

    // HUD updates
    invLabel.textContent = `Nugs: ${state.inv}/2`;
    smokedLabel.textContent = `Smoked: ${state.smoked}`;
    const canSmoke = state.inv >= 2 && !state.ended;
    prompt.style.display = canSmoke ? 'block' : 'none';
    smokeBtn.style.display = canSmoke ? 'inline-block' : 'none';

    // Speech bubble lifetime
    if (speaking.active && now() > speaking.until) {
      speaking.active = false;
    }
  }

  function render() {
    // Clear
    ctx.clearRect(0,0,VIEW_W,VIEW_H);

    // Background (tile parallax)
    const bg = assets.images.bg;
    if (bg) {
      const parallax = 0.5;
      const offset = -Math.floor(state.camX * parallax) % bg.width;
      for (let x=offset - bg.width; x<VIEW_W; x+=bg.width) {
        ctx.drawImage(bg, x, 0, bg.width, VIEW_H);
      }
    } else {
      // fallback flat color
      ctx.fillStyle = '#223';
      ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }

    // Ground line (subtle)
    ctx.fillStyle = 'rgba(0,0,0,.25)';
    ctx.fillRect(0, GROUND_Y, VIEW_W, VIEW_H - GROUND_Y);

    // World to screen x
    const toScreenX = (x) => Math.round(x - state.camX);

    // Draw pickups
    for (const p of state.pickups) {
      if (p.taken) continue;
      const img = assets.images[p.kind];
      if (!img) continue;
      const sx = toScreenX(p.x);
      if (sx < -80 || sx > VIEW_W+80) continue;
      ctx.drawImage(img, sx, p.y, 48, 48);
    }

    // Draw cat
    const cat = state.cat;
    const catImg =
      cat.sprite === 'smoke' ? assets.images.cat_smoke :
      cat.sprite === 'walk'  ? assets.images.cat_walk :
                               assets.images.cat_idle;
    if (catImg) {
      drawImage(catImg, toScreenX(cat.x), cat.y, cat.w, cat.h, cat.facing === -1);
    }

    // Speech bubble (positioned ~180px above cat’s top)
    if (speaking.active) {
      const sx = toScreenX(cat.x + cat.w/2);
      const sy = cat.y - 180;
      drawSpeechBubble(speaking.text, sx, sy);
    }
  }

  // --- End overlay DOM (created now to keep exact copy text) ---
  const endEl = document.createElement('div');
  endEl.id = 'end';
  endEl.innerHTML = `
    <div class="card">
      <h2>mitsy is too stoned to continue</h2>
      <p>Refresh the page to play again.</p>
    </div>`;
  document.body.appendChild(endEl);

  // --- Resize handling (keep internal res, CSS scales to fit) ---
  const onResize = () => {
    // Canvas uses CSS sizing only; nothing to do for fixed internal resolution
    // but we can update HUD prompt visibility if very small screens want to hide.
  };
  addEventListener('resize', onResize);

  // --- Start conditions: Splash visible, everything else idle ---
  // (All loading waits until gameplay begins so the splash shows quickly.)
})();
</script>
</body>
</html>
